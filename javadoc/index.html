<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="de">
<head>
<!-- Generated by javadoc (15) on Fri Mar 18 15:03:18 CET 2022 -->
<title>Overview</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2022-03-18">
<meta name="description" content="package index">
<meta name="generator" content="javadoc/PackageIndexWriter">
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="script.js"></script>
<script type="text/javascript" src="script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="script-dir/jquery-ui.min.js"></script>
</head>
<body class="package-index-page">
<script type="text/javascript">var pathtoroot = "./";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li class="nav-bar-cell1-rev">Overview</li>
<li>Package</li>
<li>Class</li>
<li>Use</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="deprecated-list.html">Deprecated</a></li>
<li><a href="index-all.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<div class="header">
<h1 class="title">JDrupes HTTP Codecs 2.2.0</h1>
</div>
<div class="block">HTTP codecs for non-blocking I/O.<ul>
<li><a href="#decoders">Decoders</a></li>
<li><a href="#encoders">Encoders</a></li>
<li><a href="#why-generics">Why Generics?</a></li>
<li><a href="#http-codecs">HTTP Codecs</a></li>
<li><a href="#protocol-switching">Protocol switching</a></li>
<li><a href="#engines">Engines</a></li>
<li><a href="#integration">Integration</a></li>
</ul>
<p>The HTTP codecs are modeled after the Java
<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/charset/CharsetDecoder.html" title="class or interface in java.nio.charset" class="external-link"><code>CharsetDecoder</code></a> and
<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/charset/CharsetEncoder.html" title="class or interface in java.nio.charset" class="external-link"><code>CharsetEncoder</code></a>.
An HTTP decoder is an engine that transforms a sequence
of bytes into a sequence of HTTP requests or responses (and streams
their body data). An HTTP encoder transforms an HTTP request or
response (including streamed body data) into a sequence of bytes.</p>
<p>The main difference between the Charset codecs and the HTTP codecs API
is due to the type of the decoded data. For Charset codecs this is a
homogeneous stream of <code>chars</code>, which is easy to handle. For HTTP codecs,
it&rsquo;s a mixture of headers and body data which can again consist
of either <code>byte</code>s or <code>char</code>s.</p>
<h2 id="decoders"><a href="#decoders" id="decoders">Decoders</a></h2>
<p>Decoders realize the <a href="org/jdrupes/httpcodec/Decoder.html" title="interface in org.jdrupes.httpcodec"><code>Decoder</code></a> interface.</p>
<p><img src="org/jdrupes/httpcodec/decoder.svg" alt="Decoder diagram" /></p>
<p>Binary data received from the network stream is passed to the<br />
<a href="org/jdrupes/httpcodec/Decoder.html#decode(java.nio.ByteBuffer,java.nio.Buffer,boolean)"><code>Decoder.decode(java.nio.ByteBuffer, java.nio.Buffer, boolean)</code></a> method in
a <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link"><code>ByteBuffer</code></a>. The method consumes as much data
as possible from the buffer and returns the result of the decoding
process.</p>
<p><img src="org/jdrupes/httpcodec/decoder-result.svg" alt="Decoder result" /></p>
<p>&lt;img align=&quot;right&quot;src=&ldquo;org/jdrupes/httpcodec/handle-decode-result.svg&rdquo;/&gt;</p>
<p>The basic information provided by the decoding process (defined in
<a href="org/jdrupes/httpcodec/Codec.Result.html" title="class in org.jdrupes.httpcodec"><code>Codec.Result</code></a>) is
known from the Charset codecs. &ldquo;Underflow&rdquo; indicates that more input
data is needed in order to complete the decoding of the message.
&ldquo;Overflow&rdquo; indicates that the output buffer is full. &ldquo;Close connection&rdquo;
is mostly set by encoders and indicates that the connection
should be closed. This is explained in more detail in the next section.</p>
<p>Besides streams with body data, decoders such as an HTTP decoder
provide the headers that precede this (payload) data. The successful decoding
of a header is indicated in the result by
<a href="org/jdrupes/httpcodec/Decoder.Result.html#isHeaderCompleted()"><code>Decoder.Result.isHeaderCompleted()</code></a>. The
decoded header can be retrieved with
<a href="org/jdrupes/httpcodec/Decoder.html#header()"><code>Decoder.header()</code></a>. Of course, if the
receive buffer is rather small and the header rather big, it may
take several decoder invocations before a header becomes available.</p>
<p>Sometimes, a protocol requires a provisional feedback to be sent after
receiving the message header. Because the decoder cannot send this
feedback itself, it provides the message to be sent in such cases
with <a href="org/jdrupes/httpcodec/Decoder.Result.html#response()"><code>Decoder.Result.response()</code></a>.</p>
<p>If a received message violates the protocol or represents
some kind of &ldquo;ping&rdquo; message, sending back the prepared response message
may be all that has to be done. These cases are indicated by
<a href="org/jdrupes/httpcodec/Decoder.Result.html#isResponseOnly()"><code>Decoder.Result.isResponseOnly()</code></a>).</p>
<h2 id="encoders"><a href="#encoders" id="encoders">Encoders</a></h2>
<p>Encoders realize the <a href="org/jdrupes/httpcodec/Encoder.html" title="interface in org.jdrupes.httpcodec"><code>Encoder</code></a> interface.</p>
<p><img src="org/jdrupes/httpcodec/encoder.svg" alt="Decoder diagram" /></p>
<p>Encoding is started with a call to
<a href="org/jdrupes/httpcodec/Encoder.html#encode(java.nio.ByteBuffer)"><code>Encoder.encode(MessageHeader)</code></a>. Subsequent
calls to
<a href="org/jdrupes/httpcodec/Encoder.html#encode(java.nio.Buffer,java.nio.ByteBuffer,boolean)"><code>Encoder.encode(Buffer, ByteBuffer, boolean)</code></a>
fill the output buffer with the encoded header and the body data.
If the information in the header indicates that the message does not
have a body, <a href="org/jdrupes/httpcodec/Encoder.html#encode(java.nio.ByteBuffer)"><code>Encoder.encode(ByteBuffer)</code></a>
can be called.</p>
<p>The result of the encode method is a <code>Codec.Result</code> that indicates
whether the output buffer is full and/or further body data is required.
In addition, <code>Codec.Result.closeConnection</code>
may indicate that the connection, to which the message is sent, should
be closed after sending the message. This indication
is needed because closing the connection is sometimes required by protocols
to complete a message exchange. As an encoder cannot close the connection
itself, this must be done by the invoker (the manager of the connection).</p>
<h2 id="why-generics"><a href="#why-generics" id="why-generics">Why Generics?</a></h2>
<p>While the previous sections explain the interfaces and classes with
reference to HTTP, you don&rsquo;t find &ldquo;HTTP&rdquo; in the names or methods
of the types discussed. The reason is that the API presented above
can be used to handle any &ldquo;HTTP like&rdquo; protocol (header with payload).
We need such a general interface because modern HTTP provides the
upgrade mechanism that allows the client or server to switch to another
protocol. This is currently mostly used for the web socket protocol.
More about that later.</p>
<h2 id="http-codecs"><a href="#http-codecs" id="http-codecs">HTTP Codecs</a></h2>
<p>An HTTP decoder is a special decoder that returns
<a href="org/jdrupes/httpcodec/protocols/http/HttpMessageHeader.html" title="class in org.jdrupes.httpcodec.protocols.http"><code>HttpMessageHeader</code></a>s
in its <a href="org/jdrupes/httpcodec/protocols/http/HttpDecoder.html#header()"><code>HttpDecoder.header()</code></a>
method (type parameter <code>T</code>). Of course, if
the result of the <code>decode</code> method  includes a response,
it&rsquo;s also of type <a href="org/jdrupes/httpcodec/protocols/http/HttpMessageHeader.html" title="class in org.jdrupes.httpcodec.protocols.http"><code>HttpMessageHeader</code></a>
(type parameter <code>R</code>).</p>
<p><img src="org/jdrupes/httpcodec/http-decoder.svg" alt="HTTP Decoder" /></p>
<p>In addition, it is possible to specify a maximum header length to
prevent a malicious request from filling all your memory. And you can
<a href="org/jdrupes/httpcodec/protocols/http/HttpDecoder.html#isClosed()">query</a>
if the decoder has reached the closed state, i.e. won&rsquo;t decode more messages,
because the connection should be closed (if indicated by the result) or
will be closed at the other end after sending a final response.</p>
<p>The HTTP encoder is derived in a similar way.</p>
<p><img src="org/jdrupes/httpcodec/http-encoder.svg" alt="HTTP Decoder" /></p>
<p>See the method description for the meaning of &ldquo;pending limit&rdquo;.</p>
<p>As you can see, we still haven&rsquo;t reached the goal yet to get concrete
HTTP codecs. This is because there is a difference between HTTP request
messages and HTTP response messages.</p>
<p><img src="org/jdrupes/httpcodec/http-messages.svg" alt="HTTP request and response messages" /></p>
<p>Now we have all the pieces together. In order to write an HTTP server
you need an <code>HttpDecoder</code> parameterized with <code>HttpRequest</code> as type of the
decoded message and <code>HttpResponse</code> as type of any preliminary
feedback (optionally provided by the <code>Decoder.Result</code>). This is
what makes up an
<a href="org/jdrupes/httpcodec/protocols/http/server/HttpRequestDecoder.html" title="class in org.jdrupes.httpcodec.protocols.http.server"><code>HttpRequestDecoder</code></a>.
And you need an <code>HttpEncoder</code> parameterized with <code>HttpRequest</code> as type
of the messages to be encode, in short an
<a href="org/jdrupes/httpcodec/protocols/http/server/HttpResponseEncoder.html" title="class in org.jdrupes.httpcodec.protocols.http.server"><code>HttpResponseEncoder</code></a>.</p>
<p>For implementing an HTTP client, you need an <a href="org/jdrupes/httpcodec/protocols/http/client/HttpRequestEncoder.html" title="class in org.jdrupes.httpcodec.protocols.http.client"><code>HttpRequestEncoder</code></a>
and an <a href="org/jdrupes/httpcodec/protocols/http/client/HttpResponseDecoder.html" title="class in org.jdrupes.httpcodec.protocols.http.client"><code>HttpResponseDecoder</code></a>.</p>
<p>Have a look at the classes javadoc to find out what kind of support each
of the codecs provides regarding header field handling.</p>
<h2 id="protocol-switching"><a href="#protocol-switching" id="protocol-switching">Protocol switching</a></h2>
<p>HTTP supports a client initiated upgrade from the HTTP protocol to some
other protocol on the same connection. If the upgrade request is confirmed
by the server, subsequent messages from the client are sent using the new
protocol. This, of course, requires using different codecs.</p>
<p>Those codecs, or at least a subset of their functionality, is actually
already required when the confirmation response is encoded. HTTP allows
the confirmation response to contain information that is related
to the new protocol. Obviously, this information cannot be provided by
the HTTP encoder, because it knows nothing about the new protocol.</p>
<p>The HTTP encoder therefore takes the following approach. When the header
to be encoded contains the confirmation of a protocol switch, it
uses the <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ServiceLoader.html" title="class or interface in java.util" class="external-link"><code>ServiceLoader</code></a> to find an appropriate
protocol provider. Protocol providers must be derived from
<a href="org/jdrupes/httpcodec/plugin/UpgradeProvider.html" title="class in org.jdrupes.httpcodec.plugin"><code>UpgradeProvider</code></a>. Whether a
protocol provider supports a given protocol can be checked with the
method <a href="org/jdrupes/httpcodec/plugin/UpgradeProvider.html#supportsProtocol(java.lang.String)"><code>UpgradeProvider.supportsProtocol(java.lang.String)</code></a>.
The library contains by default the
<a href="org/jdrupes/httpcodec/protocols/websocket/WsProtocolProvider.html" title="class in org.jdrupes.httpcodec.protocols.websocket"><code>WsProtocolProvider</code></a>,
the probably best known use case for an HTTP protocol upgrade.</p>
<p>If the <a href="org/jdrupes/httpcodec/protocols/http/server/HttpResponseEncoder.html" title="class in org.jdrupes.httpcodec.protocols.http.server"><code>HttpResponseEncoder</code></a>
cannot find a suitable protocol provider, it modifies the response
to deny the protocol switch. Else, it asks the provider to
<a href="org/jdrupes/httpcodec/plugin/UpgradeProvider.html#augmentInitialResponse(org.jdrupes.httpcodec.protocols.http.HttpResponse)"><code>apply any require changes</code></a> to the confirming response.</p>
<p>The <a href="org/jdrupes/httpcodec/protocols/http/server/HttpResponseEncoder.html" title="class in org.jdrupes.httpcodec.protocols.http.server"><code>HttpResponseEncoder</code></a>
returns an extended result type that implements the
<a href="org/jdrupes/httpcodec/Codec.ProtocolSwitchResult.html" title="interface in org.jdrupes.httpcodec"><code>Codec.ProtocolSwitchResult</code></a> interface.</p>
<p><img src="org/jdrupes/httpcodec/responseencoderresult.svg" alt="ProtocolSwitchResult" /></p>
<p>When the encoder finishes the encoding of an upgrade confirmation,
<a href="org/jdrupes/httpcodec/Codec.ProtocolSwitchResult.html#newProtocol()"><code>Codec.ProtocolSwitchResult.newProtocol()</code></a>
returns the name of the new protocol (in all other cases it returns
<code>null</code>). In addition, the result also provides new codecs obtained
from the plugin provider. These codecs must be used for all subsequent
requests and responses.</p>
<h2 id="engines"><a href="#engines" id="engines">Engines</a></h2>
<p>The codecs provided here are deliberatly restricted to using
<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/Buffer.html" title="class or interface in java.nio" class="external-link"><code>Buffer</code></a>s at their interface. They cannot acquire or
send such buffers, as this would tie this library with stream
mechanisms beyond the passing of <code>Buffer</code>s. It is therefore not
possible to provide autonomous engine functionality
such as automatically sending a preliminary response (as described above).</p>
<p>Nevertheless, the package includes a
<a href="org/jdrupes/httpcodec/ClientEngine.html" title="class in org.jdrupes.httpcodec"><code>ClientEngine</code></a> and a
<a href="org/jdrupes/httpcodec/ServerEngine.html" title="class in org.jdrupes.httpcodec"><code>ServerEngine</code></a>. Both simply group
together a decoder and an encoder as required for client-side
or server-side operation. As support function, they adapt themselves
to any protocol change, i.e. they replace the engine&rsquo;s codecs if
the encoder result includes new ones.</p>
<h2 id="integration"><a href="#integration" id="integration">Integration</a></h2>
<p>The <a href="https://github.com/mnlipp/jdrupes-httpcodec/blob/master/demo/org/jdrupes/httpcodec/demo/Connection.java" target="_top">demo server code</a> demonstrates how the HTTP codecs can be used
to implement a single threaded, blocking HTTP server. Of course, this
is not what this library is intended for. It should, however, give you
an idea how to integrate the HTTP codecs in your streaming environment.</p>
<p>An example of integrating this library in an event driven framework
can be found in the <a href="http://mnlipp.github.io/jgrapes/" target="_top">JGrapes project</a>.</p>
</div>
<div class="overview-summary" id="all-packages-table">
<table class="summary-table">
<caption><span>Packages</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Package</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color" id="i0">
<th class="col-first" scope="row"><a href="org/jdrupes/httpcodec/package-summary.html">org.jdrupes.httpcodec</a></th>
<td class="col-last">
<div class="block">The entry point interfaces and classes.</div>
</td>
</tr>
<tr class="row-color" id="i1">
<th class="col-first" scope="row"><a href="org/jdrupes/httpcodec/plugin/package-summary.html">org.jdrupes.httpcodec.plugin</a></th>
<td class="col-last">
<div class="block">Provides the API for adding &ldquo;upgrade&rdquo; protocols</div>
</td>
</tr>
<tr class="alt-color" id="i2">
<th class="col-first" scope="row"><a href="org/jdrupes/httpcodec/protocols/http/package-summary.html">org.jdrupes.httpcodec.protocols.http</a></th>
<td class="col-last">
<div class="block">Classes required for handling the HTTP protocol.</div>
</td>
</tr>
<tr class="row-color" id="i3">
<th class="col-first" scope="row"><a href="org/jdrupes/httpcodec/protocols/http/client/package-summary.html">org.jdrupes.httpcodec.protocols.http.client</a></th>
<td class="col-last">
<div class="block">HTTP codecs required on the client side.</div>
</td>
</tr>
<tr class="alt-color" id="i4">
<th class="col-first" scope="row"><a href="org/jdrupes/httpcodec/protocols/http/server/package-summary.html">org.jdrupes.httpcodec.protocols.http.server</a></th>
<td class="col-last">
<div class="block">HTTP codecs required on the server side.</div>
</td>
</tr>
<tr class="row-color" id="i5">
<th class="col-first" scope="row"><a href="org/jdrupes/httpcodec/protocols/websocket/package-summary.html">org.jdrupes.httpcodec.protocols.websocket</a></th>
<td class="col-last">
<div class="block">Classes for handling the Websocket protocol.</div>
</td>
</tr>
<tr class="alt-color" id="i6">
<th class="col-first" scope="row"><a href="org/jdrupes/httpcodec/types/package-summary.html">org.jdrupes.httpcodec.types</a></th>
<td class="col-last">&nbsp;</td>
</tr>
<tr class="row-color" id="i7">
<th class="col-first" scope="row"><a href="org/jdrupes/httpcodec/util/package-summary.html">org.jdrupes.httpcodec.util</a></th>
<td class="col-last">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottom-nav" id="navbar.bottom">
<div class="skip-nav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.bottom.firstrow" class="nav-list" title="Navigation">
<li class="nav-bar-cell1-rev">Overview</li>
<li>Package</li>
<li>Class</li>
<li>Use</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="deprecated-list.html">Deprecated</a></li>
<li><a href="index-all.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
<div class="about-language"><script type="text/javascript" charset="utf-8" src="./highlight.pack.js"></script>
<script type="text/javascript"><!--
var cssId = 'highlightCss';
if (!document.getElementById(cssId))
{
    var head  = document.getElementsByTagName('head')[0];
    var link  = document.createElement('link');
    link.id   = cssId;
    link.rel  = 'stylesheet';
    link.type = 'text/css';
    link.charset = 'utf-8';
    link.href = './highlight.css';
    link.media = 'all';
    head.appendChild(link);
}hljs.initHighlightingOnLoad();
//--></script></div>
</div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<span class="skip-nav" id="skip.navbar.bottom">
<!--   -->
</span></nav>
<p class="legal-copy"><small><div>
    <!-- Optional footer data -->
    <p id=githubfooter style="padding: 5px 6px; visibility: hidden">Hosted on GitHub Pages &mdash; 
    <a href="https://github.com/site/terms" target="_top">Terms</a>
    &mdash; <a href="https://github.com/site/privacy" target="_top">Privacy</a></p>
    <script type="text/javascript">
    if (location.hostname.indexOf("github") !== -1) {
        document.getElementById("githubfooter").style.visibility="visible";
    }
    </script>
    <noscript>
        <div>JavaScript is disabled on your browser, terms and privacy links may not be shown correctly.</div>
    </noscript>
</div></small></p>
</footer>
</div>
</div>
</body>
</html>
